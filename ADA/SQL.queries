-- change over time analysis

select
year(order_date),
sum(sales_amount) as total_sales,
count( DISTINCT customer_key) as total_customers,
sum(price) as total_quantity
from gold.fact_sales
where order_date is not null
group by year(order_date),month(order_date)
order by year(order_date),month(order_date);


-- performance analysis


with yearly_product_sales as(
SELECT
YEAR(f.order_date)as order_year,
p.product_name,
sum(f.sales_amount)as current_sales
from gold.fact_sales f 
left join gold.dim_products p
on f.product_key=p.product_key
where f.order_date is not null
group by
year(f.order_date),
p.product_name
)
select
order_year,
product_name,
current_sales,
avg(current_sales)over(partition by product_name)as avg_sales,
current_sales - avg(current_sales)over (partition by product_name) as diff_avg,
case
when current_sales-avg(current_sales)over (partition by product_name)>0 then 'above avg'
when current_sales-avg(current_sales)over (partition by product_name)<0 then 'below avg'
else'avg'
end as avg_change,
    lag(current_sales) over (partition by product_name order by order_year) as py_sales,
    current_sales - lag(current_sales) over (partition by product_name order by order_year) as diff_py,
    case
    when current_sales - lag(current_sales) over (partition by product_name order by order_year) >0 then 'increase'
	when current_sales - lag(current_sales) over (partition by product_name order by order_year) <0 then 'decrease'
    else'no change'
    end as py_change
from yearly_product_sales


-- part to whole analysis


with category_sales as (
select
category,
sum(f.sales_amount) as total_sales
from gold.fact_sales f
left join gold.dim_products p
     on p.product_key=f.product_key
	group by p.category
    )
select
category,
total_sales ,
sum(total_sales)over () as overall_sales
from category_sales


-- segmenting customers based on their lifespan and spending behaviour


with customer_spending as (
select
c.customer_key,
sum(f.sales_amount) as total_spending,
min(order_date)as first_order,
max(order_date) as last_order,
timestampdiff(month,min(order_date),max(order_date)) as lifespan
from gold.fact_sales f
left join gold.dim_customers c
on f.customer_key = c.customer_key
group by c.customer_key
)
select
customer_segment,
    COUNT(customer_key) as total_customers
from(
	SELECT
	 customer_key,
	 case
	    when lifespan >= 12 and total_spending>5000 then 'VIP'
		when lifespan >= 12 and total_spending<=5000 then 'REGULAR'
	    ELSE 'NEW'
	 END AS customer_segment
   from customer_spending
)as segmented_customers
group by customer_segment
order by total_customers desc;
